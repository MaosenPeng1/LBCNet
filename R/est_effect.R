#' Estimate Causal Effects
#'
#' @description This is a generic function that estimates causal effects for different object types.
#' It automatically dispatches the appropriate method based on the class of `object`.
#'
#' @param object An object to calculate effects.
#' @param Y Numeric vector of observed outcomes.
#' @param ... Additional arguments (ignored).
#'
#' @return Returns values of effects.
#'
#' @details
#' This function uses S3 method dispatching to call the appropriate method based on the object type.
#' It is designed for estimating causal effects in settings with continuous or binary outcomes.
#' For survival outcomes, users should apply appropriate survival analysis models, such as a
#' weighted Cox model or other time-to-event estimation methods. For `lbc_net` objects, see
#' \code{\link{est_effect.lbc_net}} for more details. Additional object types may be supported in the future.
#'
#' @export
est_effect <- function(object, Y, ...) {
  if (missing(object) || is.null(object)) {
    return(est_effect.lbc_net(object = NULL, Y = Y, ...))
  }
  UseMethod("est_effect")
}

#' Estimate Weighted Outcomes, ATE, or ATT for an lbc_net object
#'
#' @description Computes the weighted mean outcome, average treatment effect (ATE),
#' or average treatment effect on the treated (ATT). Y must be provided, and users can either supply an
#' `lbc_net` object (which automatically extracts weights and treatment assignments)
#' or manually provide `Tr` and `wt`.
#'
#' @param object Optional. An object of class `"lbc_net"` generated by \code{\link{lbc_net}}.
#'   If provided, `Tr` and `wt` will be extracted automatically.
#' @param Y Numeric vector of observed outcomes.
#' @param Tr Optional. Numeric binary vector (0/1) indicating treatment assignment.
#'   Required if `object` is NULL.
#' @param wt Optional. Numeric vector of inverse probability weights.
#'   Required if `object` is NULL.
#' @param type Character string specifying the desired estimate. The default is `"ATE"`, which computes
#'   the average treatment effect. Setting `type = "ATT"` estimates the average treatment effect on the treated, while
#'   `type = "Y"` returns the weighted mean outcome for the treated group (`Tr = 1`). If an object is provided, the estimate will be
#'   consistent with the object's specification, but users can also select `"Y"`.
#' @param ... Additional arguments passed to the specific method.
#'
#' @return A numeric value representing the estimated quantity.
#'
#' @details
#' It is designed for estimating causal effects in settings with continuous or binary outcomes.
#' For survival outcomes, users should apply appropriate survival analysis models, such as a
#' weighted Cox model or other time-to-event estimation methods.
#'
#' Inverse Probability Weighting (IPW) is used to estimate the treatment effect, where the weight for subject \eqn{i} is:
#' \deqn{
#' W_i = \frac{\omega^*(p_i)}{ T_i p_i + (1 - T_i)(1 - p_i) }.
#' }
#'
#' The frequency weight function \eqn{\omega^{*}(p_i)} determines the target population:
#' setting \eqn{\omega^{*}(p_i) = 1} yields the Average Treatment Effect (ATE), while
#' choosing \eqn{\omega^{*}(p_i) = p_i} results in the Average Treatment Effect on the Treated (ATT).
#'
#' The population-level treatment effect is estimated as:
#' \deqn{
#' \Delta = \frac{E(\omega^*(p_i) \Delta_i)}{E(\omega^*(p_i))},
#' }
#' where \eqn{\Delta_i = E[Y_i(1) - Y_i(0) \mid \mathbf{Z}_i]} represents the individual conditional treatment effect.
#'
#' The inverse probability weighted (IPW) estimator for ATE or ATT follows:
#' \deqn{
#' \hat{\Delta} = \frac{\sum_{i=1}^N T_i W_i Y_i}{\sum_{i=1}^N T_i W_i} - \frac{\sum_{i=1}^N (1-T_i) W_i Y_i}{\sum_{i=1}^N (1-T_i) W_i}.
#' }
#'
#' @note This function does not compute variance estimates due to computational cost.
#'   Users can obtain variance estimates via bootstrapping, ensuring that inverse probability weights (`wt`)
#'   are recomputed using `lbc_net()` for each resampled dataset. To improve efficiency, consider using parallel computing
#'   with the `foreach` and `doParallel` package.
#'
#' @examples
#' # Simulated example
#' set.seed(123)
#' Y <- rnorm(100)  # Random outcome
#' Tr <- rbinom(100, 1, 0.5)  # Random treatment assignment
#' wt <- runif(100, 0.5, 1.5)  # Random inverse probability weights
#'
#' # Manually specify Tr and wt
#' est_effect(Y = Y, Tr = Tr, wt = wt, type = "Y")
#' est_effect(Y = Y, Tr = Tr, wt = wt, type = "ATE")
#' est_effect(Y = Y, Tr = Tr, wt = wt, type = "ATT")
#'
#' \dontrun{
#' # Use an lbc_net object
#' model <- lbc_net(data = data, formula = Tr ~ X1 + X2 + X3 + X4)
#' est_effect(object = model, Y, type = "Y")
#'
#' }
#' @export
est_effect.lbc_net <- function(object = NULL, Y, Tr = NULL, wt = NULL, type = "ATE", ...) {
  
  ## 1. Extract from lbc_net object if provided
  if (!is.null(object)) {
    if (!inherits(object, "lbc_net")) {
      stop("Error: `object` must be an object of class 'lbc_net'.")
    }
    
    Tr <- getLBC(object, "Tr")        # Extract treatment assignment
    wt <- getLBC(object, "weights")   # Extract inverse probability weights
    
    # If user did NOT explicitly request type = "Y",
    # infer ATE/ATT from the object.
    if (missing(type) || type != "Y") {
      type <- ifelse(getLBC(object, "ate_flag") == 1, "ATE", "ATT")
    }
  }
  
  ## 2. Validate type (to match test expectations)
  valid_types <- c("Y", "ATE", "ATT")
  if (is.null(type) || length(type) != 1L || !type %in% valid_types) {
    stop("Error: `type` must be one of 'Y', 'ATE', or 'ATT'.")
  }
  
  ## 3. Ensure required inputs are provided
  if (is.null(Tr) || is.null(wt)) {
    stop("Error: Must provide `Tr` and `wt` manually if `object` is NULL.")
  }
  
  ## 4. Basic type/length checks
  if (!is.numeric(Y) || !is.numeric(wt) || !is.numeric(Tr)) {
    stop("Error: All inputs (Y, wt, Tr) must be numeric vectors.")
  }
  if (length(Y) != length(wt) || length(Y) != length(Tr)) {
    stop("Error: Y, wt, and Tr must have the same length.")
  }
  
  Y  <- as.numeric(Y)
  Tr <- as.numeric(Tr)
  wt <- as.numeric(wt)
  
  ## Helper: weighted mean
  wmean <- function(x, w) sum(w * x) / sum(w)
  
  ## 5. Type = "Y": overall weighted mean, ignoring Tr
  ##    (so it stays finite even if all Tr==0 or all Tr==1)
  if (type == "Y") {
    denom <- sum(wt)
    if (denom == 0 || !is.finite(denom)) {
      warning("Sum of weights is zero or non-finite. Returning NaN.")
      return(NaN)
    }
    return(sum(wt * Y) / denom)
  }
  
  ## 6. Prepare group masks for ATE/ATT
  treated  <- (Tr == 1)
  control  <- (Tr == 0)
  
  ## 7. Type = "ATE"
  if (type == "ATE") {
    
    # Edge cases: all treated or all control
    if (all(treated)) {
      warning("All units are treated (Tr = 1). Cannot compute ATE.")
      return(NaN)
    }
    if (all(control)) {
      warning("All units are control (Tr = 0). Cannot compute ATE.")
      return(NaN)
    }
    
    denom_t <- sum(wt[treated])
    denom_c <- sum(wt[control])
    
    if (denom_t == 0 || denom_c == 0) {
      warning("Treated or control group has zero total weight. Cannot compute ATE.")
      return(NaN)
    }
    
    mu1 <- sum(wt[treated]  * Y[treated])  / denom_t
    mu0 <- sum(wt[control]  * Y[control])  / denom_c
    
    return(mu1 - mu0)
  }
  
  ## 8. Type = "ATT"
  if (type == "ATT") {
    # ATT is among the treated; still need both groups to define contrast
    
    if (all(!treated)) {
      warning("No treated units (Tr = 1). Cannot compute ATT.")
      return(NaN)
    }
    if (all(!control)) {
      warning("No control units (Tr = 0). Cannot compute ATT.")
      return(NaN)
    }
    
    denom_t <- sum(treated)          # unweighted mean among treated (your original choice)
    denom_c <- sum(wt[control])      # weighted mean among controls
    
    if (denom_t == 0 || denom_c == 0) {
      warning("Treated or control group has zero count/weight. Cannot compute ATT.")
      return(NaN)
    }
    
    mu1_treated <- sum(Y[treated])            / denom_t
    mu0_treated <- sum(wt[control] * Y[control]) / denom_c
    
    return(mu1_treated - mu0_treated)
  }
  
  ## 9. Fallback (should be unreachable due to earlier type check)
  stop("Error: `type` must be one of 'Y', 'ATE', or 'ATT'.")
}

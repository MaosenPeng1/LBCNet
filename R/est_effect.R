#' Estimate Causal Effects
#'
#' @description This is a generic function that estimates causal effects for different object types.
#' It automatically dispatches the appropriate method based on the class of `object`.
#'
#' @param object An object to calculate effects.
#' @param Y Numeric vector of observed outcomes.
#' @param ... Additional arguments (ignored).
#'
#' @return Returns values of effects.
#'
#' @details
#' This function uses S3 method dispatching to call the appropriate method based on the object type.
#' It is designed for estimating causal effects in settings with continuous or binary outcomes.
#' For survival outcomes, users should apply appropriate survival analysis models, such as a
#' weighted Cox model or other time-to-event estimation methods. For `lbc_net` objects, see
#' \code{\link{est_effect.lbc_net}} for more details. Additional object types may be supported in the future.
#'
#' @export
est_effect <- function(object, Y, ...) {
  if (missing(object) || is.null(object)) {
    return(est_effect.lbc_net(object = NULL, Y = Y, ...))
  }
  UseMethod("est_effect")
}

#' Estimate Weighted Outcomes, ATE, or ATT for an lbc_net object
#'
#' @description Computes the weighted mean outcome, average treatment effect (ATE),
#' or average treatment effect on the treated (ATT). Y must be provided, and users can either supply an
#' `lbc_net` object (which automatically extracts weights and treatment assignments)
#' or manually provide `Tr` and `wt`.
#'
#' @param object Optional. An object of class `"lbc_net"` generated by \code{\link{lbc_net}}.
#'   If provided, `Tr` and `wt` will be extracted automatically.
#' @param Y Numeric vector of observed outcomes.
#' @param Tr Optional. Numeric binary vector (0/1) indicating treatment assignment.
#'   Required if `object` is NULL.
#' @param wt Optional. Numeric vector of inverse probability weights.
#'   Required if `object` is NULL.
#' @param type Character string specifying the desired estimate. The default is `"ATE"`, which computes
#'   the average treatment effect. Setting `type = "ATT"` estimates the average treatment effect on the treated, while
#'   `type = "Y"` returns the weighted mean outcome for the treated group (`Tr = 1`). If an object is provided, the estimate will be
#'   consistent with the object's specification, but users can also select `"Y"`.
#' @param ... Additional arguments passed to the specific method.
#'
#' @return A numeric value representing the estimated quantity.
#'
#' @details
#' It is designed for estimating causal effects in settings with continuous or binary outcomes.
#' For survival outcomes, users should apply appropriate survival analysis models, such as a
#' weighted Cox model or other time-to-event estimation methods.
#'
#' Inverse Probability Weighting (IPW) is used to estimate the treatment effect, where the weight for subject \eqn{i} is:
#' \deqn{
#' W_i = \frac{\omega^*(p_i)}{ T_i p_i + (1 - T_i)(1 - p_i) }.
#' }
#'
#' The frequency weight function \eqn{\omega^{*}(p_i)} determines the target population:
#' setting \eqn{\omega^{*}(p_i) = 1} yields the Average Treatment Effect (ATE), while
#' choosing \eqn{\omega^{*}(p_i) = p_i} results in the Average Treatment Effect on the Treated (ATT).
#'
#' The population-level treatment effect is estimated as:
#' \deqn{
#' \Delta = \frac{E(\omega^*(p_i) \Delta_i)}{E(\omega^*(p_i))},
#' }
#' where \eqn{\Delta_i = E[Y_i(1) - Y_i(0) \mid \mathbf{Z}_i]} represents the individual conditional treatment effect.
#'
#' The inverse probability weighted (IPW) estimator for ATE or ATT follows:
#' \deqn{
#' \hat{\Delta} = \frac{\sum_{i=1}^N T_i W_i Y_i}{\sum_{i=1}^N T_i W_i} - \frac{\sum_{i=1}^N (1-T_i) W_i Y_i}{\sum_{i=1}^N (1-T_i) W_i}.
#' }
#'
#' @note This function does not compute variance estimates due to computational cost.
#'   Users can obtain variance estimates via bootstrapping, ensuring that inverse probability weights (`wt`)
#'   are recomputed using `lbc_net()` for each resampled dataset. To improve efficiency, consider using parallel computing
#'   with the `foreach` and `doParallel` package.
#'
#' @examples
#' # Simulated example
#' set.seed(123)
#' Y <- rnorm(100)  # Random outcome
#' Tr <- rbinom(100, 1, 0.5)  # Random treatment assignment
#' wt <- runif(100, 0.5, 1.5)  # Random inverse probability weights
#'
#' # Manually specify Tr and wt
#' est_effect(Y = Y, Tr = Tr, wt = wt, type = "Y")
#' est_effect(Y = Y, Tr = Tr, wt = wt, type = "ATE")
#' est_effect(Y = Y, Tr = Tr, wt = wt, type = "ATT")
#'
#' \dontrun{
#' # Use an lbc_net object
#' model <- lbc_net(data = data, formula = Tr ~ X1 + X2 + X3 + X4)
#' est_effect(object = model, Y, type = "Y")
#'
#' }
#' @export
est_effect.lbc_net <- function(object = NULL, Y, Tr = NULL, wt = NULL, type = "ATE", ...) {

  # Extract Z, wt, and type from lbc_net object if provided
  if (!is.null(object)) {
    if (!inherits(object, "lbc_net")) {
      stop("Error: `object` must be an object of class 'lbc_net'.")
    }
    Tr <- getLBC(object, "Tr")   # Extract treatment assignment
    wt <- getLBC(object, "weights")  # Extract inverse probability weights

    # Extract type only if user has not manually set it to "Y"
    if (missing(type) || type != "Y") {
      type <- ifelse(getLBC(object, "ATE") == 1, "ATE", "ATT")
    }
  }

  # Ensure required inputs are provided
  if (is.null(Tr) || is.null(wt)) {
    stop("Error: Must provide `Tr` and `wt` manually if `object` is NULL.")
  }

  # Ensure valid data types
  if (!is.numeric(Y) || !is.numeric(wt) || !is.numeric(Tr)) {
    stop("Error: All inputs (Y, wt, Tr) must be numeric vectors.")
  }
  if (length(Y) != length(wt) || length(Y) != length(Tr)) {
    stop("Error: Y, wt, and Tr must have the same length.")
  }

  # Handle case where there is only treatment or only control
  if (all(Tr == 1)) {
    warning("All units are treated (Tr = 1). Cannot compute ATE or ATT.")
    return(NaN)
  }

  if (all(Tr == 0)) {
    warning("All units are control (Tr = 0). Cannot compute ATE or ATT.")
    return(NaN)
  }

  # Compute estimates based on type
  if (type == "Y") {
    # Weighted mean outcome for the treated group (Tr = 1)
    denom <- sum(Tr * wt)
    if (denom == 0) {
      warning("Sum of weighted treatment group is zero. Returning NaN.")
      return(NaN)
    }
    return(sum(Tr * wt * Y) / denom)
  }

  if (type == "ATE") {
    # ATE: Difference between weighted means of treated & control
    ATE_treated <- sum(Tr * wt * Y) / sum(Tr * wt)
    ATE_control_denom <- sum((1 - Tr) * wt)

    if (ATE_control_denom == 0) {
      warning("Control group sum is zero. Cannot compute ATE.")
      return(NaN)
    }

    ATE_control <- sum((1 - Tr) * wt * Y) / ATE_control_denom
    return(ATE_treated - ATE_control)
  }

  if (type == "ATT") {
    # ATT: Treatment effect among the treated group
    ATT_treated_denom <- sum(Tr)
    ATT_control_denom <- sum((1 - Tr) * wt)

    if (ATT_control_denom == 0) {
      warning("Control group sum is zero. Cannot compute ATT.")
      return(NaN)
    }

    ATT_treated <- sum(Tr * Y) / ATT_treated_denom  # Mean outcome for treated
    ATT_control <- sum((1 - Tr) * wt * Y) / ATT_control_denom  # Weighted mean for controls

    return(ATT_treated - ATT_control)
  }

  stop("Error: `type` must be one of 'Y', 'ATE', or 'ATT'.")
}


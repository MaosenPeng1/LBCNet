#' Summary of an lbc_net Object
#'
#' @description Provides a structured summary of an `lbc_net` object,
#' including loss values, balance assessments, and an optional treatment effect estimate.
#'
#' @param object An object of class `"lbc_net"`, generated by `lbc_net()`.
#' @param Y (Optional) A numeric vector of observed outcomes.
#' @param type A character string specifying the treatment effect to estimate.
#'   Options:
#'   - `"Y"`: Computes the weighted mean outcome.
#'   - `"ATE"` (default): Computes the Average Treatment Effect.
#'   - `"ATT"`: Computes the Average Treatment Effect on the Treated.
#'
#' @param ... Additional arguments (ignored).
#'
#' @return A list containing:
#' \describe{
#'   \item{\code{sample_info}}{Sample sizes and covariate counts.}
#'   \item{\code{losses}}{Training losses.}
#'   \item{\code{local_balance}}{Local standardized differences from training.}
#'   \item{\code{balance_table}}{Pre- and post-weighting global standardized differences (GSD).}
#'   \item{\code{treatment_effect}}{Estimated treatment effect, if applicable.}
#'   \item{\code{gsd}}{GSD after weighting.}
#' }
#'
#' @details
#' The function extracts key model components using \code{\link{getLBC}}.
#' If `compute_gsd = TRUE`, it calculates global balance using \code{\link{gsd}}.
#' If `Y` is provided, it estimates treatment effects using \code{\link{est_effect}}.
#'
#' It is designed for estimating causal effects in settings with continuous or binary outcomes.
#' For survival outcomes, users should apply appropriate survival analysis models, such as a
#' weighted Cox model or other time-to-event estimation methods.
#'
#' @seealso \code{\link{est_effect}}, \code{\link{gsd}}, \code{\link{getLBC}}
#'
#' @examples
#' \dontrun{
#' model <- lbc_net(data = data, formula = Tr ~ X1 + X2 + X3 + X4)
#' summary(model)  # Summary without treatment effect estimation
#' summary(model, Y = my_outcome, type = "ATE")  # Summary including treatment effect
#' 
#' out <- summary(model)
#' names(out)
#' out$balance_table
#' }
#'
#' @export
summary.lbc_net <- function(object, Y = NULL, type = "ATE", ...) {

  if (!is.null(object)) {
    if (!inherits(object, "lbc_net")) {
      stop("Error: `object` must be an object of class 'lbc_net'.")
    }
    # Extract key components using getLBC()
    losses <- getLBC(object, "losses")
    lsd_train <- getLBC(object, "lsd_train")
    formula <- getLBC(object, "formula")
    Z <- getLBC(object, "Z")
    Tr <- getLBC(object, "Tr")

    # Extract type only if user has not manually set it to "Y"
    if (missing(type) || type != "Y") {
      type <- ifelse(getLBC(object, "ATE") == 1, "ATE", "ATT")
    }
  }

  # Compute sample characteristics
  sample_size <- nrow(Z)
  num_covariates <- ncol(Z)

  # Compute treatment group sizes
  treated_size <- sum(Tr)
  control_size <- sample_size - treated_size

  # Compute pre-weighting GSD (weights = 1 for all observations)
  gsd_values_before <- gsd(Z = Z, Tr = Tr, wt = rep(1, sample_size))
  
  # Compute global standardized difference (GSD) if requested
  gsd_values_after <- gsd(object)
  
  # Combine into a table
  balance_table <- data.frame(
    Covariate = names(gsd_values_after),
    Pre_Weighting_GSD = as.numeric(gsd_values_before),
    Post_Weighting_GSD = as.numeric(gsd_values_after)
  )
  
  # Compute treatment effect if Y is provided
  if (!is.null(Y)) {
    if (length(Y) != sample_size) {
      stop("Error: `Y` must have the same length as the number of observations in the model.")
    }
    effect <- est_effect(object, Y, type = type)
  } else {
    effect <- "Effect estimate not calculated (provide `Y` to compute)."
  }

  # Print Summary
  # Format formula output
  formula_text <- deparse(formula, width.cutoff = 60)

  # Print Summary
  cat("Call:\n", formula_text, "\n")
  cat("Sample Size:", sample_size, " | Number of Covariates:", num_covariates, "\n")
  cat("Treated:", treated_size, " | Control:", control_size, "\n\n")

  cat("--- Losses ---\n")
  cat(sprintf("Balance Loss:      %.4f\n", losses$balance_loss))
  cat(sprintf("Calibration Loss:  %.4f\n", losses$calibration_loss))
  cat(sprintf("Total Loss:        %.4f\n\n", losses$total_loss))

  cat(sprintf("--- Local Balance (LSD) %s ---\n", "%"))
  cat(sprintf("Max LSD:   %.4f\n", lsd_train$lsd_max))
  cat(sprintf("Mean LSD:  %.4f\n\n", lsd_train$lsd_mean))
  
  cat(sprintf("--- Global Standardized Differences (GSD) %s ---\n", "%"))
  
  # Format for printing
  cov_names <- format(balance_table$Covariate, width = max(nchar(balance_table$Covariate)) + 2, justify = "left")
  pre_gsd_fmt <- format(sprintf("%.4f", balance_table$Pre_Weighting_GSD), width = 12, justify = "right")
  post_gsd_fmt <- format(sprintf("%.4f", balance_table$Post_Weighting_GSD), width = 12, justify = "right")
  
  # Header row
  cat(format("Covariate", width = max(nchar(balance_table$Covariate)) + 2, justify = "left"),
      format("Pre-GSD", width = 12, justify = "right"),
      format("Post-GSD", width = 12, justify = "right"), "\n")
  
  cat(strrep("-", max(nchar(balance_table$Covariate)) + 30), "\n")
  
  # Print each row
  for (i in seq_along(cov_names)) {
    cat(cov_names[i], pre_gsd_fmt[i], post_gsd_fmt[i], "\n")
  }
  cat("\n")

  cat("--- Treatment Effect Estimate ---\n")
  if (is.null(Y)) {
    cat("Effect estimate not calculated. Provide `Y` to compute.\n")
  } else {
    # Define type label (default to "ATE" if not explicitly specified)
    effect_label <- if (!missing(type)) toupper(type) else "ATE"

    # Print the effect estimate with four decimal places
    cat(sprintf("%s: %.4f\n", effect_label, effect))
  }
  
  # Return object
  summary_list <- list(
    sample_info = list(
      sample_size = sample_size,
      treated_size = treated_size,
      control_size = control_size,
      num_covariates = num_covariates
    ),
    losses = losses,
    local_balance = list(
      lsd_max = lsd_train$lsd_max,
      lsd_mean = lsd_train$lsd_mean
    ),
    balance_table = balance_table,
    treatment_effect = if (!is.null(Y)) {
      list(
        type = effect_label,
        estimate = effect
      )
    } else {
      NULL
    },
    gsd = gsd_values_after
  )
  
  invisible(summary_list)

}

#' Summary of an lsd Object
#'
#' @description Provides a structured summary of an `lsd` object.
#'
#' @param object An object of class `"lsd"`, generated by `lsd()`.
#' @param ... Additional arguments passed to the specific method.
#'
#' @return A structured summary of the `lbc_net` object, including:
#' \itemize{
#'   \item Average local balance over all cks for each covariate.
#'   \item Local balance summary: `lsd_max`, `lsd_mean` for local standardized mean difference calculated during training.
#'   \item Sample characteristics: `sample_size`, `num_covariates`, `treated_size`, `control_size`.
#' }
#'
#' @details
#' The function extracts key model components using \code{\link{getLBC}}.
#'
#' @seealso \code{\link{getLBC}}
#'
#' @examples
#' \dontrun{
#' model <- lbc_net(data = data, formula = Tr ~ X1 + X2 + X3 + X4)
#' lsd_result <- lsd(model)
#' summary(lsd_result)
#' }
#'
#' @importFrom stats formula
#' @importFrom dplyr %>%
#' @export
summary.lsd <- function(object, ...) {
  if (!inherits(object, "lsd")) {
    stop("Error: `object` must be of class 'lsd'.")
  }

  # Extract key components using getLBC()
  LSD_mean <- getLBC(object, "LSD_mean")
  LSD_max <- getLBC(object, "LSD_max")
  LSD <- getLBC(object, "LSD")
  Z <- getLBC(object, "Z")
  Tr <- getLBC(object, "Tr")
  ATE <- getLBC(object, "ATE")

  # Compute sample characteristics
  sample_size <- nrow(Z)
  num_covariates <- ncol(Z)

  # Compute treatment group sizes
  treated_size <- sum(Tr)
  control_size <- sample_size - treated_size

  # Convert ATE integer to descriptive string
  ATE_label <- if (ATE == 1) "ATE (Average Treatment Effect)" else "ATT (Average Treatment Effect on the Treated)"

  # Print Summary
  # Format formula output
  formula_text <- deparse(formula, width.cutoff = 60)

  # Print Summary
  cat("Call:\n", formula_text, "\n")
  cat("Sample Size:", sample_size, " | Number of Covariates:", num_covariates, "\n")
  cat("Treated:", treated_size, " | Control:", control_size, "\n")
  cat("Estimand:", ATE_label, "\n\n")

  cat(sprintf("--- Local Balance (LSD) %s ---\n", "%"))
  cat(sprintf("Max LSD:   %.4f\n", LSD_max))
  cat(sprintf("Mean LSD:  %.4f\n\n", LSD_mean))

  # Convert LSD named vector to a dataframe
  lsd_df <- data.frame(
    Covariate = if (!is.null(colnames(LSD))) {
      colnames(LSD)
    } else {
      paste0("Z", seq_len(ncol(LSD)))  # Generate Z1, Z2, ..., Zp if colnames are NULL
    },
    LSD = sprintf("%.4f", as.numeric(colMeans(LSD)))
  )

  # Define column width for alignment
  max_name_length <- max(nchar(lsd_df$Covariate)) + 2  # Adjust spacing
  formatted_covariate <- format(lsd_df$Covariate, width = max_name_length, justify = "left")
  formatted_lsd <- format(lsd_df$LSD, width = 7, justify = "right")

  cat(format("Covariates", width = max_name_length, justify = "left"),
      format("LSD %", width = 7, justify = "right"), "\n")
  cat(strrep("-", max_name_length + 9), "\n")

  # Print table with proper alignment
  for (i in seq_along(formatted_covariate)) {
    cat(formatted_covariate[i], formatted_lsd[i], "\n")
  }

  cat("\n")

}

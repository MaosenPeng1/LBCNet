#' Extract Components from an Object
#'
#' @description This is a generic function used to extract components from different object types.
#' The function dispatches the appropriate method based on the class of `object`, ensuring
#' users can retrieve key model outputs from supported objects such as `"lbc_net"` and `lsd`.
#'
#' @param object An object from which to extract components.
#' @param name The name(s) of the component(s) to extract.
#' @return The requested component(s), based on the specific method for the object's class.
#'
#' @details
#' This function uses S3 method dispatching to call the appropriate method based on the
#' object type. For example:
#' If `object` is of class `"lbc_net"` or `"lsd"`, see \code{\link{getLBC.lbc_net}} and \code{\link{getLBC.lsd}} for details.
#' Additional object types may be supported in the future.
#'
#' @examples
#' \dontrun{
#' fit <- lbc_net(data = my_data, formula = Tr ~ X1 + X2)
#' getLBC(fit, "fitted.values")  # Extract propensity scores
#' }
#'
#' @export
getLBC <- function(object, name) {
  UseMethod("getLBC")  # Calls the appropriate method for the object type
}

#' Extract Components from an lbc_net Object
#'
#' @description Retrieves specific components from an `lbc_net` object.
#' This function provides a structured way to access key results,
#' ensuring users retrieve the correct model components.
#'
#' @param object An object of class `"lbc_net"`, generated by \code{\link{lbc_net}}.
#' @param name A character vector specifying the name(s) of the component(s) to extract.
#'   If name = "ALL", a named list of all available components will be returned.
#'   Available options include:
#'   \describe{
#'     \item{"fitted.values"}{Estimated propensity scores.}
#'     \item{"weights"}{Inverse probability weights (IPW).}
#'     \item{"loss"}{The final total loss value.}
#'
#'     \item{"lsd_train"}{A list containing key local standardized mean difference (LSD) values
#'       recorded during training:
#'       \itemize{
#'         \item lsd_max – Maximum local standardized mean difference observed during training.
#'         \item lsd_mean – Mean local standardized mean difference observed during training.
#'       }
#'       The complete LSD profile can be computed using the function lsd().
#'     }
#'
#'     \item{"parameters"}{Model hyperparameters such as hidden_dim, L, vae_lr, lr,
#'       weight_decay, balance_lambda, epsilon.}
#'
#'     \item{"stopping_criteria"}{Stopping parameters including lsd_threshold,
#'       rolling_window, and max_epochs.}
#'
#'     \item{"seed"}{Random seed used for reproducibility.}
#'     \item{"call"}{The matched function call.}
#'     \item{"formula"}{Formula used (if applicable).}
#'     \item{"Z"}{Covariate matrix used.}
#'     \item{"Tr"}{Treatment assignment vector.}
#'     \item{"ck"}{Kernel center values used.}
#'     \item{"h"}{Bandwidth values used.}
#'     \item{"K"}{Number of kernel points.}
#'     \item{"rho"}{Span parameter used to construct bandwidths.}
#'     \item{"ate_flag"}{ATE or ATT flag used in the loss.}
#'     \item{"kernel"}{Kernel used to define local neighbourhoods.}
#'     \item{"ps_logistic"}{Propensity scores fitted via logistic regression.}
#'
#'     \item{"estimand"}{Target estimand such as ATE, ATT, or Y.}
#'     \item{"effect"}{Estimated causal effect (if computed).}
#'     \item{"se"}{Estimated standard error (if computed).}
#'     \item{"ci"}{Confidence interval for the estimated effect.}
#'   }
#'
#' @return The requested component(s) from the `lbc_net` object. Default returns "fitted.values".
#' If multiple names are provided or if `name = "ALL"`, a named list of components is returned.
#'
#' @examples
#' \dontrun{
#' model <- lbc_net(data = data, formula = Tr ~ X1 + X2 + X3 + X4)
#' getLBC(model, "fitted.values")  # Extract propensity scores
#' getLBC(model, c("fitted.values", "weights"))  # Extract multiple components
#' getLBC(model, "ALL")  # Extract all components as a named list
#' }
#' @export
getLBC.lbc_net <- function(object, name = "fitted.values") {
  # Ensure the input is an `lbc_net` object
  if (!inherits(object, "lbc_net")) {
    stop("Error: `object` must be of class 'lbc_net'.")
  }

  if (!is.character(name) || length(name) == 0) {
    stop("Error: `name` must be a non-empty character vector.")
  }

  # Define valid components
  valid_components <- c("fitted.values", "weights", "loss", "lsd_train", "parameters", "estimand",
                        "stopping_criteria", "ate_flag", "seed", "call", "formula", "Z",
                        "Tr", "ck", "h", "K", "rho", "kernel", "ps_logistic", "effect", "se", "ci")

  # If "ALL" is requested, return the entire object as a named list
  if (identical(name, "ALL")) {
    return(object)
  }

  # Validate requested components
  invalid_names <- setdiff(name, valid_components)
  if (length(invalid_names) > 0) {
    stop("Invalid component name(s): ", paste(invalid_names, collapse = ", "),
         ". Use one of: ", paste(valid_components, collapse = ", "))
  }

  # Extract requested components
  result <- object[name]

  # Return a named list if multiple components are requested, otherwise return a single value
  if (length(name) == 1) {
    return(result[[1]])
  } else {
    return(result)
  }
}

#' Extract Components from an lsd Object
#'
#' @description Retrieves specific components from an `lsd` object.
#' This function provides a structured way to access key results,
#' ensuring users retrieve the correct model components.
#'
#' @param object An object of class `"lsd"`, generated by \code{\link{lsd}}.
#' @param name A character vector specifying the name(s) of the component(s) to extract.
#'   If `name = "ALL"`, a named list of all available components will be returned.
#'   Available options include:
#'   \describe{
#'     \item{`"LSD"`}{A matrix of LSD values for each covariate at each `ck`.}
#'     \item{`"LSD_mean"`}{The mean absolute LSD value across all covariates.}
#'     \item{`"LSD_max"`}{The maximum absolute LSD value.}
#'     \item{`"Z"`}{Covariate matrix used.}
#'     \item{`"Tr"`}{Treatment assignment vector.}
#'     \item{`"ck"`}{Kernel center values used.}
#'     \item{`"h"`}{Bandwidth values used.}
#'     \item{`"K"`}{Number of kernel points.}
#'     \item{`"rho"`}{Span values used.}
#'     \item{`"ate_flag"`}{ATE or ATT aim for estimate.}
#'     \item{`"kernel"`}{kernel used to define local neibourhood.}
#'   }
#'
#' @return The requested component(s) from the `lbc_net` object. Default returns "fitted.values".
#' If multiple names are provided or if `name = "ALL"`, a named list of components is returned.
#'
#' @examples
#' \dontrun{
#' model <- lbc_net(data = data, formula = Tr ~ X1 + X2 + X3 + X4)
#' LSD.fit <- lsd(model)
#' getLBC(LSD.fit, "LSD")
#' getLBC(LSD.fit, c("LSD", "LSD_mean"))  # Extract multiple components
#' getLBC(LSD.fit, "ALL")  # Extract all components as a named list
#' }
#' @export
getLBC.lsd <- function(object, name = "LSD_mean") {
  # Ensure the input is an `lsd` object
  if (!inherits(object, "lsd")) {
    stop("Error: `object` must be of class 'lsd'.")
  }

  if (!is.character(name) || length(name) == 0) {
    stop("Error: `name` must be a non-empty character vector.")
  }

  # Define valid components
  valid_components <- c("LSD", "LSD_mean", "LSD_max", "Z",
                        "Tr", "ck", "h", "K", "rho", "ate_flag", "kernel")

  # If "ALL" is requested, return the entire object as a named list
  if (identical(name, "ALL")) {
    return(object)
  }

  # Validate requested components
  invalid_names <- setdiff(name, valid_components)
  if (length(invalid_names) > 0) {
    stop("Invalid component name(s): ", paste(invalid_names, collapse = ", "),
         ". Use one of: ", paste(valid_components, collapse = ", "))
  }

  # Extract requested components
  result <- object[name]

  # Return a named list if multiple components are requested, otherwise return a single value
  if (length(name) == 1) {
    return(result[[1]])
  } else {
    return(result)
  }
}

#' Extract Components from an lbc_net_surv Object
#'
#' @description
#' Retrieves specific components from an \code{"lbc_net_surv"} object.
#' This function provides a structured way to access key results for
#' survival outcomes, ensuring users retrieve the correct model components.
#'
#' @param object An object of class \code{"lbc_net_surv"}, generated by
#'   \code{\link{lbc_net_surv}}.
#' @param name A character vector specifying the name(s) of the component(s)
#'   to extract. If \code{name = "ALL"}, the entire object (as a named list)
#'   will be returned.
#'
#'   Available options include:
#'   \describe{
#'     \item{\code{"fitted.values"}}{Estimated propensity scores.}
#'     \item{\code{"weights"}}{Inverse probability weights (IPW) calculated as
#'       \eqn{1 / (A \hat e(X) + (1-A)\{1-\hat e(X)\})}.}
#'     \item{\code{"loss"}}{Final total training loss value from LBC-Net.}
#'     \item{\code{"lsd_train"}}{A list containing key local standardized mean
#'       difference (LSD) values recorded during training:
#'       \itemize{
#'         \item \code{lsd_max} – Maximum LSD at the final epoch.
#'         \item \code{lsd_mean} – Mean LSD at the final epoch.
#'       }
#'       Note: the full local balance profile can be recomputed using
#'       \code{\link{lsd}} for further evaluation.}
#'     \item{\code{"parameters"}}{Model hyperparameters including (typically)
#'       \code{hidden_dim}, \code{num_hidden_layers}, \code{vae_lr}, \code{lr},
#'       \code{weight_decay}, \code{balance_lambda}, \code{epsilon}.}
#'     \item{\code{"stopping_criteria"}}{Stopping parameters including
#'       \code{lsd_threshold}, \code{rolling_window}, and \code{max_epochs}.}
#'     \item{\code{"seed"}}{Random seed used for reproducibility.}
#'     \item{\code{"call"}}{The matched function call for reference.}
#'     \item{\code{"formula"}}{Formula used (if applicable).}
#'     \item{\code{"Z"}}{Covariate matrix used.}
#'     \item{\code{"Tr"}}{Treatment assignment vector.}
#'     \item{\code{"time"}}{Event or censoring times used in the survival analysis.}
#'     \item{\code{"delta"}}{Event indicator (1 = event, 0 = censored).}
#'     \item{\code{"ck"}}{Kernel center values used.}
#'     \item{\code{"h"}}{Bandwidth values used.}
#'     \item{\code{"K"}}{Number of kernel points.}
#'     \item{\code{"rho"}}{Span value used to construct bandwidths.}
#'     \item{\code{"kernel"}}{Kernel used to define local neighbourhood.}
#'     \item{\code{"ps_logistic"}}{Propensity scores fitted via logistic regression.}
#'     \item{\code{"survival"}}{A list containing survival-related outputs, e.g.,
#'       evaluation times, survival curves \code{S1}, \code{S0}, survival
#'       differences, variances, and confidence intervals.}
#'   }
#'
#' @return
#' The requested component(s) from the \code{"lbc_net_surv"} object.
#' If a single name is provided, the corresponding component is returned directly.
#' If multiple names are provided, a named list is returned.
#' If \code{name = "ALL"}, the full object is returned.
#'
#' @examples
#' \dontrun{
#' fit_surv <- lbc_net_surv(
#'   data    = dat,
#'   formula = Tr ~ X1 + X2,
#'   time    = "time",
#'   delta   = "delta"
#' )
#' getLBC(fit_surv, "survival")     # Extract survival curves and differences
#' getLBC(fit_surv, c("fitted.values", "weights"))  # PS and weights
#' }
#'
#' @export
getLBC.lbc_net_surv <- function(object, name = "fitted.values") {
  # Ensure the input is an `lbc_net_surv` object
  if (!inherits(object, "lbc_net_surv")) {
    stop("Error: `object` must be of class 'lbc_net_surv'.")
  }
  
  if (!is.character(name) || length(name) == 0L) {
    stop("Error: `name` must be a non-empty character vector.")
  }
  
  # Define valid components for survival objects
  valid_components <- c(
    "fitted.values", "weights", "loss", "lsd_train", "parameters",
    "stopping_criteria", "seed", "call", "formula", "Z",
    "Tr", "time", "delta", "ck", "h", "K", "rho", "kernel",
    "ps_logistic", "survival", "ate_flag"
  )
  
  # If "ALL" is requested, return the entire object as a named list
  if (identical(name, "ALL")) {
    return(object)
  }
  
  # Validate requested components
  invalid_names <- setdiff(name, valid_components)
  if (length(invalid_names) > 0L) {
    stop(
      "Invalid component name(s): ", paste(invalid_names, collapse = ", "),
      ". Use one of: ", paste(valid_components, collapse = ", ")
    )
  }
  
  # Extract requested components
  result <- object[name]
  
  # Return a named list if multiple components are requested, otherwise a single value
  if (length(name) == 1L) {
    return(result[[1]])
  } else {
    return(result)
  }
}

#' @export
getLBC.NULL <- function(object, ...) {
  stop("Error: `object` must be of class 'lbc_net'.")
}

getLBC.default <- function(object, ...) {
  stop("Error: `object` must be of class 'lbc_net'.")
}
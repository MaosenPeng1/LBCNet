#' Extract Components from an Object
#'
#' @description This is a generic function used to extract components from different object types.
#' The function dispatches the appropriate method based on the class of `object`, ensuring
#' users can retrieve key model outputs from supported objects such as `"lbc_net"` and `lsd`.
#'
#' @param object An object from which to extract components.
#' @param name The name(s) of the component(s) to extract.
#' @return The requested component(s), based on the specific method for the object's class.
#'
#' @details
#' This function uses S3 method dispatching to call the appropriate method based on the
#' object type. For example:
#' If `object` is of class `"lbc_net"` or `"lsd"`, see \code{\link{getLBC.lbc_net}} and \code{\link{getLBC.lsd}} for details.
#' Additional object types may be supported in the future.
#'
#' @examples
#' \dontrun{
#' fit <- lbc_net(data = my_data, formula = Tr ~ X1 + X2)
#' getLBC(fit, "fitted.values")  # Extract propensity scores
#' }
#'
#' @export
getLBC <- function(object, name) {
  UseMethod("getLBC")  # Calls the appropriate method for the object type
}

#' Extract Components from an lbc_net Object
#'
#' @description Retrieves specific components from an `lbc_net` object.
#' This function provides a structured way to access key results,
#' ensuring users retrieve the correct model components.
#'
#' @param object An object of class `"lbc_net"`, generated by \code{\link{lbc_net}}.
#' @param name A character vector specifying the name(s) of the component(s) to extract.
#'   If `name = "ALL"`, a named list of all available components will be returned.
#'   Available options include:
#'   \describe{
#'     \item{`"fitted.values"`}{Estimated propensity scores.}
#'     \item{`"weights"`}{Inverse probability weights (IPW) calculated as `1 / (ps * Tr + (1 - ps) * (1 - Tr))`.}
#'     \item{`"losses"`}{A list containing:
#'       \itemize{
#'         \item `balance_loss` - The final balance loss value.
#'         \item `calibration_loss` - The final calibration loss value.
#'         \item `total_loss` - The final total loss value.
#'       }
#'     }
#'    \item{`"lsd_train"`}{A list containing key local standardized mean difference (LSD) values
#'      recorded during training. These values can be used to tune hyperparameters along with loss metrics.
#'      \itemize{
#'        \item `lsd_max` - The maximum local standardized mean difference (LSD) observed during training.
#'        \item `lsd_mean` - The mean LSD value computed over training epochs.
#'      }
#'      Note: These measures are derived from the training process, the complete LSD values can be computed using \code{\link{lsd}}
#'      for further evaluation.
#'    }
#'     \item{`"parameters"`}{Model hyperparameters including `hidden_dim`, `L`, `vae_lr`, `lr`, `weight_decay`, `balance_lambda`, `epsilon`.}
#'     \item{`"stopping_criteria"`}{Stopping parameters including `lsd_threshold`, `rolling_window`, `max_epochs`.}
#'     \item{`"seed"`}{Random seed used for reproducibility.}
#'     \item{`"call"`}{The matched function call for reference.}
#'     \item{`"formula"`}{Formula used (if applicable).}
#'     \item{`"Z"`}{Covariate matrix used.}
#'     \item{`"Tr"`}{Treatment assignment vector.}
#'     \item{`"ck"`}{Kernel center values used.}
#'     \item{`"h"`}{Bandwidth values used.}
#'     \item{`"K"`}{Number of kernel points.}
#'     \item{`"rho"`}{Span values used.}
#'     \item{`"ATE"`}{ATE or ATT aim for estimate.}
#'     \item{`"kernel"`}{kernel used to define local neibourhood.}
#'     \item{`"ps_logistic"`}{Propensity scores fitted via logistic regression.}
#'   }
#'
#' @return The requested component(s) from the `lbc_net` object. Default returns "fitted.values".
#' If multiple names are provided or if `name = "ALL"`, a named list of components is returned.
#'
#' @examples
#' \dontrun{
#' model <- lbc_net(data = data, formula = Tr ~ X1 + X2 + X3 + X4)
#' getLBC(model, "fitted.values")  # Extract propensity scores
#' getLBC(model, c("fitted.values", "weights"))  # Extract multiple components
#' getLBC(model, "ALL")  # Extract all components as a named list
#' }
#' @export
getLBC.lbc_net <- function(object, name = "fitted.values") {
  # Ensure the input is an `lbc_net` object
  if (!inherits(object, "lbc_net")) {
    stop("Error: `object` must be of class 'lbc_net'.")
  }

  if (!is.character(name) || length(name) == 0) {
    stop("Error: `name` must be a non-empty character vector.")
  }

  # Define valid components
  valid_components <- c("fitted.values", "weights", "losses", "lsd_train", "parameters",
                        "stopping_criteria", "ATE", "seed", "call", "formula", "Z",
                        "Tr", "ck", "h", "K", "rho", "kernel", "ps_logistic")

  # If "ALL" is requested, return the entire object as a named list
  if (identical(name, "ALL")) {
    return(object)
  }

  # Validate requested components
  invalid_names <- setdiff(name, valid_components)
  if (length(invalid_names) > 0) {
    stop("Invalid component name(s): ", paste(invalid_names, collapse = ", "),
         ". Use one of: ", paste(valid_components, collapse = ", "))
  }

  # Extract requested components
  result <- object[name]

  # Return a named list if multiple components are requested, otherwise return a single value
  if (length(name) == 1) {
    return(result[[1]])
  } else {
    return(result)
  }
}

#' Extract Components from an lsd Object
#'
#' @description Retrieves specific components from an `lsd` object.
#' This function provides a structured way to access key results,
#' ensuring users retrieve the correct model components.
#'
#' @param object An object of class `"lsd"`, generated by \code{\link{lsd}}.
#' @param name A character vector specifying the name(s) of the component(s) to extract.
#'   If `name = "ALL"`, a named list of all available components will be returned.
#'   Available options include:
#'   \describe{
#'     \item{`"LSD"`}{A matrix of LSD values for each covariate at each `ck`.}
#'     \item{`"LSD_mean"`}{The mean absolute LSD value across all covariates.}
#'     \item{`"LSD_max"`}{The maximum absolute LSD value.}
#'     \item{`"Z"`}{Covariate matrix used.}
#'     \item{`"Tr"`}{Treatment assignment vector.}
#'     \item{`"ck"`}{Kernel center values used.}
#'     \item{`"h"`}{Bandwidth values used.}
#'     \item{`"K"`}{Number of kernel points.}
#'     \item{`"rho"`}{Span values used.}
#'     \item{`"ATE"`}{ATE or ATT aim for estimate.}
#'     \item{`"kernel"`}{kernel used to define local neibourhood.}
#'   }
#'
#' @return The requested component(s) from the `lbc_net` object. Default returns "fitted.values".
#' If multiple names are provided or if `name = "ALL"`, a named list of components is returned.
#'
#' @examples
#' \dontrun{
#' model <- lbc_net(data = data, formula = Tr ~ X1 + X2 + X3 + X4)
#' LSD.fit <- lsd(model)
#' getLBC(LSD.fit, "LSD")
#' getLBC(LSD.fit, c("LSD", "LSD_mean"))  # Extract multiple components
#' getLBC(LSD.fit, "ALL")  # Extract all components as a named list
#' }
#' @export
getLBC.lsd <- function(object, name = "LSD_mean") {
  # Ensure the input is an `lsd` object
  if (!inherits(object, "lsd")) {
    stop("Error: `object` must be of class 'lsd'.")
  }

  if (!is.character(name) || length(name) == 0) {
    stop("Error: `name` must be a non-empty character vector.")
  }

  # Define valid components
  valid_components <- c("LSD", "LSD_mean", "LSD_max", "Z",
                        "Tr", "ck", "h", "K", "rho", "ATE", "kernel")

  # If "ALL" is requested, return the entire object as a named list
  if (identical(name, "ALL")) {
    return(object)
  }

  # Validate requested components
  invalid_names <- setdiff(name, valid_components)
  if (length(invalid_names) > 0) {
    stop("Invalid component name(s): ", paste(invalid_names, collapse = ", "),
         ". Use one of: ", paste(valid_components, collapse = ", "))
  }

  # Extract requested components
  result <- object[name]

  # Return a named list if multiple components are requested, otherwise return a single value
  if (length(name) == 1) {
    return(result[[1]])
  } else {
    return(result)
  }
}
